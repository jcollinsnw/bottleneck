"use strict";

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _toArray2 = require("babel-runtime/helpers/toArray");

var _toArray3 = _interopRequireDefault(_toArray2);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 2.2.4
(function () {
  var Bottleneck,
      DEFAULT_PRIORITY,
      DLList,
      Events,
      Local,
      NUM_PRIORITIES,
      Sync,
      packagejson,
      parser,
      splice = [].splice;

  NUM_PRIORITIES = 10;

  DEFAULT_PRIORITY = 5;

  parser = require("./parser");

  Local = require("./Local");

  Events = require("./Events");

  DLList = require("./DLList");

  Sync = require("./Sync");

  packagejson = require("../package.json");

  Bottleneck = function () {
    var Bottleneck = function () {
      function Bottleneck() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, Bottleneck);

        var sDefaults;
        this.ready = this.ready.bind(this);
        this.clients = this.clients.bind(this);
        this.disconnect = this.disconnect.bind(this);
        this.chain = this.chain.bind(this);
        this.queued = this.queued.bind(this);
        this.running = this.running.bind(this);
        this.check = this.check.bind(this);
        this._drainOne = this._drainOne.bind(this);
        this.submit = this.submit.bind(this);
        this.schedule = this.schedule.bind(this);
        this.wrap = this.wrap.bind(this);
        this.updateSettings = this.updateSettings.bind(this);
        this.currentReservoir = this.currentReservoir.bind(this);
        this.incrementReservoir = this.incrementReservoir.bind(this);
        if (!(options != null && (typeof options === "undefined" ? "undefined" : (0, _typeof3.default)(options)) === "object" && (arguments.length <= 1 ? 0 : arguments.length - 1) === 0)) {
          throw new Bottleneck.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
        }
        parser.load(options, this.instanceDefaults, this);
        this._queues = this._makeQueues();
        this._executing = {};
        this._limiter = null;
        this.Events = new Events(this);
        this._submitLock = new Sync("submit");
        this._registerLock = new Sync("register");
        sDefaults = parser.load(options, this.storeDefaults, {});
        this._store = function () {
          if (this.datastore === "local") {
            return new Local(parser.load(options, this.storeInstanceDefaults, sDefaults));
          } else {
            throw new Bottleneck.prototype.BottleneckError("Invalid datastore type: " + this.datastore);
          }
        }.call(this);
      }

      (0, _createClass3.default)(Bottleneck, [{
        key: "ready",
        value: function ready() {
          return this._store.ready;
        }
      }, {
        key: "clients",
        value: function clients() {
          return this._store.clients;
        }
      }, {
        key: "disconnect",
        value: function () {
          var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
            var flush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            return _regenerator2.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._store.disconnect(flush);

                  case 2:
                    return _context.abrupt("return", _context.sent);

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function disconnect() {
            return _ref.apply(this, arguments);
          }

          return disconnect;
        }()
      }, {
        key: "_makeQueues",
        value: function _makeQueues() {
          var i, j, ref, results;
          results = [];
          for (i = j = 1, ref = NUM_PRIORITIES; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
            results.push(new DLList());
          }
          return results;
        }
      }, {
        key: "chain",
        value: function chain(_limiter) {
          this._limiter = _limiter;
          return this;
        }
      }, {
        key: "_sanitizePriority",
        value: function _sanitizePriority(priority) {
          var sProperty;
          sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
          if (sProperty < 0) {
            return 0;
          } else if (sProperty > NUM_PRIORITIES - 1) {
            return NUM_PRIORITIES - 1;
          } else {
            return sProperty;
          }
        }
      }, {
        key: "_find",
        value: function _find(arr, fn) {
          var ref;
          return (ref = function () {
            var i, j, len, x;
            for (i = j = 0, len = arr.length; j < len; i = ++j) {
              x = arr[i];
              if (fn(x)) {
                return x;
              }
            }
          }()) != null ? ref : [];
        }
      }, {
        key: "queued",
        value: function queued(priority) {
          if (priority != null) {
            return this._queues[priority].length;
          } else {
            return this._queues.reduce(function (a, b) {
              return a + b.length;
            }, 0);
          }
        }
      }, {
        key: "empty",
        value: function empty() {
          return this.queued() === 0 && this._submitLock.isEmpty();
        }
      }, {
        key: "running",
        value: function () {
          var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
            return _regenerator2.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this._store.__running__();

                  case 2:
                    return _context2.abrupt("return", _context2.sent);

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function running() {
            return _ref2.apply(this, arguments);
          }

          return running;
        }()
      }, {
        key: "_getFirst",
        value: function _getFirst(arr) {
          return this._find(arr, function (x) {
            return x.length > 0;
          });
        }
      }, {
        key: "_randomIndex",
        value: function _randomIndex() {
          return Math.random().toString(36).slice(2);
        }
      }, {
        key: "check",
        value: function () {
          var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
            var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            return _regenerator2.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._store.__check__(weight);

                  case 2:
                    return _context3.abrupt("return", _context3.sent);

                  case 3:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function check() {
            return _ref3.apply(this, arguments);
          }

          return check;
        }()
      }, {
        key: "_run",
        value: function _run(next, wait, index) {
          var _this = this;

          var completed, done;
          this.Events.trigger("debug", ["Scheduling " + next.options.id, {
            args: next.args,
            options: next.options
          }]);
          done = false;
          completed = function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              var e, ref, running, _ref5;

              return _regenerator2.default.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (done) {
                        _context4.next = 20;
                        break;
                      }

                      _context4.prev = 1;

                      done = true;
                      clearTimeout(_this._executing[index].expiration);
                      delete _this._executing[index];
                      _this.Events.trigger("debug", ["Completed " + next.options.id, {
                        args: next.args,
                        options: next.options
                      }]);
                      _context4.next = 8;
                      return _this._store.__free__(index, next.options.weight);

                    case 8:
                      _ref5 = _context4.sent;
                      running = _ref5.running;

                      _this.Events.trigger("debug", ["Freed " + next.options.id, {
                        args: next.args,
                        options: next.options
                      }]);
                      _this._drainAll().catch(function (e) {
                        return _this.Events.trigger("error", [e]);
                      });
                      if (running === 0 && _this.empty()) {
                        _this.Events.trigger("idle", []);
                      }
                      return _context4.abrupt("return", (ref = next.cb) != null ? ref.apply({}, args) : void 0);

                    case 16:
                      _context4.prev = 16;
                      _context4.t0 = _context4["catch"](1);

                      e = _context4.t0;
                      return _context4.abrupt("return", _this.Events.trigger("error", [e]));

                    case 20:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, _this, [[1, 16]]);
            }));

            return function completed() {
              return _ref4.apply(this, arguments);
            };
          }();
          return this._executing[index] = {
            timeout: setTimeout(function () {
              _this.Events.trigger("debug", ["Executing " + next.options.id, {
                args: next.args,
                options: next.options
              }]);
              if (_this._limiter != null) {
                return _this._limiter.submit.apply(_this._limiter, Array.prototype.concat(next.options, next.task, next.args, completed));
              } else {
                return next.task.apply({}, next.args.concat(completed));
              }
            }, wait),
            expiration: next.options.expiration != null ? setTimeout(function () {
              return completed(new Bottleneck.prototype.BottleneckError("This job timed out after " + next.options.expiration + " ms."));
            }, next.options.expiration) : void 0,
            job: next
          };
        }
      }, {
        key: "_drainOne",
        value: function _drainOne(freed) {
          var _this2 = this;

          return this._registerLock.schedule(function () {
            var args, index, options, queue;
            if (_this2.queued() === 0) {
              return _this2.Promise.resolve(false);
            }
            queue = _this2._getFirst(_this2._queues);

            var _queue$first = queue.first();

            options = _queue$first.options;
            args = _queue$first.args;

            if (freed != null && options.weight > freed) {
              return _this2.Promise.resolve(false);
            }
            _this2.Events.trigger("debug", ["Draining " + options.id, { args: args, options: options }]);
            index = _this2._randomIndex();
            return _this2._store.__register__(index, options.weight, options.expiration).then(function (_ref6) {
              var success = _ref6.success,
                  wait = _ref6.wait,
                  reservoir = _ref6.reservoir;

              var empty, next;
              _this2.Events.trigger("debug", ["Drained " + options.id, { success: success, args: args, options: options }]);
              if (success) {
                next = queue.shift();
                empty = _this2.empty();
                if (empty) {
                  _this2.Events.trigger("empty", []);
                }
                if (reservoir === 0) {
                  _this2.Events.trigger("depleted", [empty]);
                }
                _this2._run(next, wait, index);
              }
              return _this2.Promise.resolve(success);
            });
          });
        }
      }, {
        key: "_drainAll",
        value: function _drainAll(freed) {
          var _this3 = this;

          return this._drainOne(freed).then(function (success) {
            if (success) {
              return _this3._drainAll();
            } else {
              return _this3.Promise.resolve(success);
            }
          }).catch(function (e) {
            return _this3.Events.trigger("error", [e]);
          });
        }
      }, {
        key: "submit",
        value: function submit() {
          var _this4 = this;

          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          var cb, job, options, ref, ref1, task;
          if (typeof args[0] === "function") {
            var _ref7, _ref8, _splice$call, _splice$call2;

            ref = args, (_ref7 = ref, _ref8 = (0, _toArray3.default)(_ref7), task = _ref8[0], args = _ref8.slice(1), _ref7), (_splice$call = splice.call(args, -1), _splice$call2 = (0, _slicedToArray3.default)(_splice$call, 1), cb = _splice$call2[0], _splice$call);
            options = this.jobDefaults;
          } else {
            var _ref9, _ref10, _splice$call3, _splice$call4;

            ref1 = args, (_ref9 = ref1, _ref10 = (0, _toArray3.default)(_ref9), options = _ref10[0], task = _ref10[1], args = _ref10.slice(2), _ref9), (_splice$call3 = splice.call(args, -1), _splice$call4 = (0, _slicedToArray3.default)(_splice$call3, 1), cb = _splice$call4[0], _splice$call3);
            options = parser.load(options, this.jobDefaults);
          }
          job = { options: options, task: task, args: args, cb: cb };
          options.priority = this._sanitizePriority(options.priority);
          this.Events.trigger("debug", ["Queueing " + options.id, { args: args, options: options }]);
          return this._submitLock.schedule((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
            var blocked, e, reachedHWM, shifted, strategy, _ref12;

            return _regenerator2.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.prev = 0;
                    _context5.next = 3;
                    return _this4._store.__submit__(_this4.queued(), options.weight);

                  case 3:
                    _ref12 = _context5.sent;
                    reachedHWM = _ref12.reachedHWM;
                    blocked = _ref12.blocked;
                    strategy = _ref12.strategy;

                    _this4.Events.trigger("debug", ["Queued " + options.id, { args: args, options: options, reachedHWM: reachedHWM, blocked: blocked }]);
                    _context5.next = 16;
                    break;

                  case 10:
                    _context5.prev = 10;
                    _context5.t0 = _context5["catch"](0);

                    e = _context5.t0;
                    _this4.Events.trigger("debug", ["Could not queue " + options.id, {
                      args: args,
                      options: options,
                      error: e
                    }]);
                    job.cb(e);
                    return _context5.abrupt("return", false);

                  case 16:
                    if (!blocked) {
                      _context5.next = 22;
                      break;
                    }

                    _this4._queues = _this4._makeQueues();
                    _this4.Events.trigger("dropped", [job]);
                    return _context5.abrupt("return", true);

                  case 22:
                    if (!reachedHWM) {
                      _context5.next = 27;
                      break;
                    }

                    shifted = strategy === Bottleneck.prototype.strategy.LEAK ? _this4._getFirst(_this4._queues.slice(options.priority).reverse()).shift() : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? _this4._getFirst(_this4._queues.slice(options.priority + 1).reverse()).shift() : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;
                    if (shifted != null) {
                      _this4.Events.trigger("dropped", [shifted]);
                    }

                    if (!(shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW)) {
                      _context5.next = 27;
                      break;
                    }

                    return _context5.abrupt("return", reachedHWM);

                  case 27:
                    _this4._queues[options.priority].push(job);
                    _context5.next = 30;
                    return _this4._drainAll();

                  case 30:
                    return _context5.abrupt("return", reachedHWM);

                  case 31:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, _this4, [[0, 10]]);
          })));
        }
      }, {
        key: "schedule",
        value: function schedule() {
          var _this5 = this;

          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          var options, task, wrapped;
          if (typeof args[0] === "function") {
            var _args6 = args;

            var _args7 = (0, _toArray3.default)(_args6);

            task = _args7[0];
            args = _args7.slice(1);

            options = this.jobDefaults;
          } else {
            var _args8 = args;

            var _args9 = (0, _toArray3.default)(_args8);

            options = _args9[0];
            task = _args9[1];
            args = _args9.slice(2);

            options = parser.load(options, this.jobDefaults);
          }
          wrapped = function wrapped() {
            var _ref13, _ref14, _splice$call5, _splice$call6;

            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }

            var cb, ref, returned;
            ref = args, (_ref13 = ref, _ref14 = (0, _toArray3.default)(_ref13), args = _ref14.slice(0), _ref13), (_splice$call5 = splice.call(args, -1), _splice$call6 = (0, _slicedToArray3.default)(_splice$call5, 1), cb = _splice$call6[0], _splice$call5);
            returned = task.apply({}, args);
            if (returned.then == null) {
              return cb(new Bottleneck.prototype.BottleneckError("The function given to `schedule()` did not return a Promise. You may need to return `Promise.resolve(data)`. You returned: " + returned + " (" + (typeof returned === "undefined" ? "undefined" : (0, _typeof3.default)(returned)) + ")"));
            }
            return returned.then(function () {
              for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
              }

              return cb.apply({}, Array.prototype.concat(null, args));
            }).catch(function () {
              for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                args[_key6] = arguments[_key6];
              }

              return cb.apply({}, args);
            });
          };
          return new this.Promise(function (resolve, reject) {
            return _this5.submit.apply({}, Array.prototype.concat(options, wrapped, args, function () {
              for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                args[_key7] = arguments[_key7];
              }

              return (args[0] != null ? reject : (args.shift(), resolve)).apply({}, args);
            })).catch(function (e) {
              return _this5.Events.trigger("error", [e]);
            });
          });
        }
      }, {
        key: "wrap",
        value: function wrap(fn) {
          var _this6 = this;

          return function () {
            for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
              args[_key8] = arguments[_key8];
            }

            return _this6.schedule.apply({}, Array.prototype.concat(fn, args));
          };
        }
      }, {
        key: "updateSettings",
        value: function () {
          var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
            var _this7 = this;

            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return _regenerator2.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return this._store.__updateSettings__(parser.overwrite(options, this.storeDefaults));

                  case 2:
                    parser.overwrite(options, this.instanceDefaults, this);
                    this._drainAll().catch(function (e) {
                      return _this7.Events.trigger("error", [e]);
                    });
                    return _context6.abrupt("return", this);

                  case 5:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function updateSettings() {
            return _ref15.apply(this, arguments);
          }

          return updateSettings;
        }()
      }, {
        key: "currentReservoir",
        value: function () {
          var _ref16 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
            return _regenerator2.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return this._store.__currentReservoir__();

                  case 2:
                    return _context7.abrupt("return", _context7.sent);

                  case 3:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function currentReservoir() {
            return _ref16.apply(this, arguments);
          }

          return currentReservoir;
        }()
      }, {
        key: "incrementReservoir",
        value: function () {
          var _ref17 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
            var _this8 = this;

            var incr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            return _regenerator2.default.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return this._store.__incrementReservoir__(incr);

                  case 2:
                    this._drainAll().catch(function (e) {
                      return _this8.Events.trigger("error", [e]);
                    });
                    return _context8.abrupt("return", this);

                  case 4:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function incrementReservoir() {
            return _ref17.apply(this, arguments);
          }

          return incrementReservoir;
        }()
      }]);
      return Bottleneck;
    }();

    ;

    Bottleneck.default = Bottleneck;

    Bottleneck.version = Bottleneck.prototype.version = packagejson.version;

    Bottleneck.strategy = Bottleneck.prototype.strategy = {
      LEAK: 1,
      OVERFLOW: 2,
      OVERFLOW_PRIORITY: 4,
      BLOCK: 3
    };

    Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = require("./BottleneckError");

    Bottleneck.Group = Bottleneck.prototype.Group = require("./Group");

    Bottleneck.prototype.jobDefaults = {
      priority: DEFAULT_PRIORITY,
      weight: 1,
      expiration: null,
      id: "<no-id>"
    };

    Bottleneck.prototype.storeDefaults = {
      maxConcurrent: null,
      minTime: 0,
      highWater: null,
      strategy: Bottleneck.prototype.strategy.LEAK,
      penalty: null,
      reservoir: null
    };

    Bottleneck.prototype.storeInstanceDefaults = {
      clientOptions: {},
      clearDatastore: false,
      Promise: Promise,
      _groupTimeout: null
    };

    Bottleneck.prototype.instanceDefaults = {
      datastore: "local",
      id: "<no-id>",
      rejectOnDrop: true,
      Promise: Promise
    };

    return Bottleneck;
  }.call(this);

  module.exports = Bottleneck;
}).call(undefined);