"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 2.2.4
(function () {
  var Events, Group, parser;

  parser = require("./parser");

  Events = require("./Events");

  Group = function () {
    var Group = function () {
      function Group() {
        var limiterOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var groupOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, _classCallCheck3.default)(this, Group);

        this.key = this.key.bind(this);
        this.deleteKey = this.deleteKey.bind(this);
        this.limiters = this.limiters.bind(this);
        this.keys = this.keys.bind(this);
        this._startAutoCleanup = this._startAutoCleanup.bind(this);
        this.updateSettings = this.updateSettings.bind(this);
        this.limiterOptions = limiterOptions;
        parser.load(groupOptions, this.defaults, this);
        this.Events = new Events(this);
        this.instances = {};
        this.Bottleneck = require("./Bottleneck");
        this._startAutoCleanup();
      }

      (0, _createClass3.default)(Group, [{
        key: "key",
        value: function key() {
          var _this = this;

          var _key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

          var ref;
          return (ref = this.instances[_key]) != null ? ref : function () {
            var limiter;
            limiter = _this.instances[_key] = new _this.Bottleneck(Object.assign(_this.limiterOptions, {
              id: "group-key-" + _key,
              _groupTimeout: _this.timeout
            }));
            _this.Events.trigger("created", [limiter, _key]);
            return limiter;
          }();
        }
      }, {
        key: "deleteKey",
        value: function deleteKey() {
          var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

          var ref;
          if ((ref = this.instances[key]) != null) {
            ref.disconnect();
          }
          return delete this.instances[key];
        }
      }, {
        key: "limiters",
        value: function limiters() {
          var k, ref, results, v;
          ref = this.instances;
          results = [];
          for (k in ref) {
            v = ref[k];
            results.push({
              key: k,
              limiter: v
            });
          }
          return results;
        }
      }, {
        key: "keys",
        value: function keys() {
          return Object.keys(this.instances);
        }
      }, {
        key: "_startAutoCleanup",
        value: function _startAutoCleanup() {
          var _this2 = this;

          var base;
          clearInterval(this.interval);
          return typeof (base = this.interval = setInterval((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
            var e, k, ref, results, time, v;
            return _regenerator2.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    time = Date.now();
                    ref = _this2.instances;
                    results = [];
                    _context.t0 = _regenerator2.default.keys(ref);

                  case 4:
                    if ((_context.t1 = _context.t0()).done) {
                      _context.next = 23;
                      break;
                    }

                    k = _context.t1.value;

                    v = ref[k];
                    _context.prev = 7;
                    _context.next = 10;
                    return v._store.__groupCheck__(time);

                  case 10:
                    if (!_context.sent) {
                      _context.next = 14;
                      break;
                    }

                    results.push(_this2.deleteKey(k));
                    _context.next = 15;
                    break;

                  case 14:
                    results.push(void 0);

                  case 15:
                    _context.next = 21;
                    break;

                  case 17:
                    _context.prev = 17;
                    _context.t2 = _context["catch"](7);

                    e = _context.t2;
                    results.push(v.Events.trigger("error", [e]));

                  case 21:
                    _context.next = 4;
                    break;

                  case 23:
                    return _context.abrupt("return", results);

                  case 24:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, _this2, [[7, 17]]);
          })), this.timeout / 2)).unref === "function" ? base.unref() : void 0;
        }
      }, {
        key: "updateSettings",
        value: function updateSettings() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          parser.overwrite(options, this.defaults, this);
          if (options.timeout != null) {
            return this._startAutoCleanup();
          }
        }
      }]);
      return Group;
    }();

    ;

    Group.prototype.defaults = {
      timeout: 1000 * 60 * 5
    };

    return Group;
  }.call(this);

  module.exports = Group;
}).call(undefined);